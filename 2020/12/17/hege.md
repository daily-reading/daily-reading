现有的编程语言在编写多异步处理任务的代码时，通常使编写者有非常糟糕的体验。当我们创建一个OS级线程去执行一个异步的代码时，我们的任务代码和管理代码分离，并且我们难以控制执行代码的生命周期，往往需要通过一个回调函数来处理。一旦这样的任务变多并变复杂，代码可读性将相当糟糕，并且很难维护。

我们知道编程语言中的控制流代码块是有着非常好的结构特性，代码块的生命周期一定会在代码块退出的时候结束。如果一个if语句的执行代码块内嵌在一个方法的代码块中，那么我们一定可以知道，当这个方法退出的时候，if语句的代码块也一定执行完成并退出了。这种特性时编程语言的代发可读可维护。那么我们时候可以设想一种新的编程范式，使异步代码有着与代码块一样的编程特性呢。

### 结构并发（Structured concurrency）

结构并发设想了一种使用Green Thread来实现的多线程编程范式。这个范式需要保证当一个方法或者一个代码块退出时，被这个方法或者这份代码块创建的其他绿色线程的异步调用也已经退出。这样我们就有了有着非常易于管理生命周期的多线程模型。

假设main()中创建了新线程调用方法foo(),在foo()中又创建了线程调用了bar()。那么结构并发要求foo()退出时，执行bar()的线程一定已经退出，同理，main()退出时，foo()所在的线程也已经退出。


### 退出机制
显然各线程执行的情况并不相同，如果当foo()需要退出时，bar()已经执行完并退出了，那么foo()就可以直接退出，但是如果bar()还没有执行完，那么foo()应该如何应对呢？

有两个显然的方式：
1. 等待bar()执行结束并退出后，foo()再进行退出。
2. 由foo()直接结束掉当前bar()的执行，并退出。

在实际的场景中，这两个场景是并存的。所以我们需要权衡这两种方式，我们可以提出一个方式，就是为这个终止加一个超时时间。当foo()执行结束需要退出时，foo()询问bar()是否已经退出，如果bar()已经执行完毕并退出，则foo()退出，如果bar()仍然在执行，则等待一个超时时间，超过这个时间bar()仍未执行完毕并退出的话，则foo()会主动结束bar()

这种退出关系会逐层传递。

如此一来，我们就理论上初步实现了结构并发。
