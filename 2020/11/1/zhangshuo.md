原文：https://medium.com/box-tech-blog/strategies-used-at-box-to-protect-mysql-at-scale-35388b85f2a4

#### Data Access Infrastructure 要求
* 严格的数据一致性
* 高吞吐量
* 低延迟
* 高可用性

#### First Step
1. 增加更多 web servers、database replicas、cache
2. 水平切分数据库

#### Add Data Access Service
* 问题：数据库连接池资源不够
* 解决：增加 Data Access Service。
    * 提供一些策略保护关键资源，例如通过限制 API 查询的数据集

#### Improving Utilization of Replicas
* 问题：主库负载增长过快
* 解决：提高 Replica 利用率。从 从库 读数据且保证数据强一致性
    1. 如果数据是同步的，直接读
    2. 如果数据不同步
        1)  直接 fail。如果副本持续延迟，会大量 fail
        2) 读主。主从延迟大，极大可能是主在频繁写，此时再请求主，会导致主压力更大
        3) 等待主从同步。同步时间没有保证，最终导致请求超时
        4) 不等到完全同步。在某些时间点，如图中 t3，也是能保证写后读一致性【看起来有这样一个思路。维护一个缓存，主写入或修改数据，就在缓存中添加对应的 key，从同步该 key 后，就将缓存中的 key 删掉。请求打到从，如果缓存中不存在要读取的 key，则不必等主同步，直接返回】

#### Improving Cache Utilization
* 问题：需要缓存的数据更少，缓存命中率更低。因为只缓存主库，从库存在不一致的风险
* 解决：采取策略提高缓存利用率。
    1. 如果确定从库和主库同步，那么也缓存从库读取的数据
    2. 缓存不存在的值
    3. 缓存 lease【在 11 月 3 号的文章里写了，这里不展开了】

#### Rate Limiting at the Data Access Layer
* 问题：个体偶尔的流量突增导致错误尖峰，应用层限流定位不到问题
* 解决：Data Access Layer 限流。
    1. 常规思路是在集群旁加一个单点。对于低延迟系统不合适，且有单点故障的风险
    2. 好的实现需要满足
        1) 无中心，所有服务都持有限流命令
        2) 容错
        3) 集群内快速传播限流命令
    3. 最终参考 [Push-Sum](https://www.cs.cornell.edu/johannes/papers/2003/focs2003-gossip.pdf)
        1) 流程：每个节点随机选择其他节点发送本地信息，接收者通过特定计算公式求和，保存到本地。每个节点重复这一流程，在一定轮数后，所有节点都持有同一个值。
        2) 改进：上述方案只适应瞬时场景，流量是连续的。改进为将时间分为多个间隙，当一个间隙 Push-Sum 达到指定轮数，即已达成共识，可以限速。

#### Quality of Service for Writes
* 问题：数据迁移等场景有大量异步写，导致副本延迟大，策略失效
* 解决：区分优先级，客户写请求正常处理，其他写请求只在所有 replicas 都没有明显的延迟时处理。【有点疑问，在有大量用户写请求情况下，如果扩容，新增一个副本，会导致数据同步，有大量异步写，在这个机制下，是不是就不会同步了，那扩容也就没用了，没看懂】

