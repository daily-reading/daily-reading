https://medium.com/datadriveninvestor/all-things-caching-use-cases-benefits-strategies-choosing-a-caching-technology-exploring-fa6c1f2e93aa

先决条件
问自己
* 是否要求高吞吐、快速返回和低延迟
* 数据不一致容忍程度？
* 什么类型数据需要存储
* 是否需要事务性
* 开源？商业性？框架提供？
* 如果用分布式缓存，表现、性能、扩展性和可用性？
缓存的好处
* 降低网络开销
* 提升响应速度
* 在同样的硬件条件下表现更好
* 网络异常下可以临时提供数据
缓存的常见use-case
* 内存内缓存
* 关系型数据库提速
* 管控尖峰流量
* Session存储
* Token缓存
* 游戏
* 网页缓存
* 全局Id/计数器
* 非高频数据缓存


缓存数据读取策略

懒加载
只有需要的时候才读缓存。
读到了，则缓存
没读到，则读数据，写缓存，再返回
优点
* 不会存全量数据
* 缓存节点挂了，不会影响系统本身
缺点
* 每次缓存miss，会有三次网络请求
* 过时的数据可能成为问题

write though（双写？）
写数据库的时候，同时更新缓存。
需要保证都成功
优点
* 无过期数据
* 适合读负载重、无法容忍不一致的情况
缺点
* 对写性能有影响。每次写操作需要写两个不同的存储
* 如果有很多数据无读取，缓存会一直占用资源

Write Behind Cache
先写缓存，在一定时间后，再异步同步到数据源
优点
* 因为读写都在缓存端，不需要等源数据更新完毕，响应很快
* 不受数据库失败的影响
* 适合高读写系统
缺点
* 缓存和数据库是最终一致性保障，所以数据库的任意操作可能都用的旧数据
系统设计限制
* 先缓存再数据库，如果无法写入数据库，则rollback 操作需要应对
* 如果是共享数据库，则会比较麻烦（现在一般可以避免?）

Refresh Ahead Cacheing
驱逐策略 Eviction Policy

* LRU
* LFU
* MRU
* FIFO

缓存策略

* 单点缓存
* 分布式缓存

实测
* memcached
    * 简单
    * 快

* redis
* Aerospike
* couchbase

Cache as a service
抽象缓存层

总结
这篇文章很全面的介绍了，从 开始考虑使用缓存，到缓存的几种写法，到缓存的策略、驱逐等常见抉择点
还列举了常见的一些缓存选型的特点、优劣适用场景。类似于一个说明书一般的文章。
值得常翻阅。
但是总体介绍还是比较浅，对于不同策略下的挑战，解决方案，如何优化等，需要结合实际去深入考虑。



